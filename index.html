<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hörselassistenten</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Anpassad slider-stil */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #4b5563;
            border-radius: 2px;
        }

        .vu-meter-bar {
            transition: height 0.1s ease;
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen font-sans flex flex-col">

    <!-- Header -->
    <header class="bg-slate-800 p-4 shadow-lg border-b border-slate-700">
        <div class="max-w-md mx-auto flex items-center justify-between">
            <h1 class="text-xl font-bold flex items-center gap-2">
                <i data-lucide="ear" class="text-blue-400"></i>
                Hörselassistenten
            </h1>
            <div id="statusIndicator" class="px-3 py-1 rounded-full text-xs font-semibold bg-red-900 text-red-200 animate-pulse">
                OFFLINE
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow p-4 overflow-y-auto">
        <div class="max-w-md mx-auto space-y-6">

            <!-- Wake Lock Status -->
            <div id="wakeLockStatus" class="hidden bg-blue-900/30 text-blue-200 text-xs text-center py-2 rounded border border-blue-800">
                <i data-lucide="sun" class="inline w-3 h-3 mr-1"></i> Skärmen hålls vaken
            </div>

            <!-- Start/Stop Section -->
            <div class="bg-slate-800 rounded-xl p-6 shadow-md border border-slate-700 text-center">
                <p class="text-slate-400 text-sm mb-4">
                    <i data-lucide="alert-triangle" class="inline w-4 h-4 mb-1 text-yellow-500"></i>
                    Använd alltid hörlurar för att undvika rundgång.
                </p>
                <button id="toggleBtn" class="w-full py-4 rounded-lg font-bold text-lg transition-all shadow-lg flex items-center justify-center gap-3 bg-green-600 hover:bg-green-500 text-white">
                    <i data-lucide="power"></i>
                    Starta Ljudet
                </button>
            </div>

            <!-- Visualizer -->
            <div class="bg-slate-800 rounded-xl p-4 shadow-md border border-slate-700 relative overflow-hidden h-32 flex items-end justify-between gap-1" id="visualizer-container">
                <!-- Bars will be injected here by JS -->
                <div class="absolute inset-0 flex items-center justify-center text-slate-500/30 font-bold text-2xl z-0 pointer-events-none">
                    VISUALISERARE
                </div>
            </div>

            <!-- Input Selection -->
            <div class="bg-slate-800 rounded-xl p-5 shadow-md border border-slate-700">
                <div class="flex justify-between items-center mb-2">
                    <label class="text-sm font-medium text-slate-400 flex items-center gap-2">
                        <i data-lucide="mic"></i> Välj Mikrofon (Input)
                    </label>
                    <button onclick="getMicrophones()" class="text-xs bg-slate-700 hover:bg-slate-600 text-white px-3 py-2 rounded flex items-center gap-1 transition-colors border border-slate-600">
                        <i data-lucide="refresh-cw" class="w-3 h-3"></i> Uppdatera
                    </button>
                </div>
                <select id="micSelect" class="w-full bg-slate-900 border border-slate-600 rounded-lg p-3 text-white focus:ring-2 focus:ring-blue-500 outline-none">
                    <option value="" disabled selected>Laddar mikrofoner...</option>
                </select>
                <p class="text-xs text-slate-500 mt-2">
                    Om din USB-C-mikrofon inte syns, testa att koppla in den igen och tryck "Uppdatera".
                </p>
            </div>

            <!-- Controls -->
            <div class="bg-slate-800 rounded-xl p-5 shadow-md border border-slate-700 space-y-6 opacity-50 pointer-events-none transition-opacity" id="controlsArea">
                
                <!-- Gain / Volume Boost -->
                <div>
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-blue-300">Volymförstärkning</label>
                        <span id="gainVal" class="text-xs font-mono bg-slate-700 px-2 rounded">1.0x</span>
                    </div>
                    <input type="range" id="gainSlider" min="0" max="5" step="0.1" value="1" class="w-full">
                    <p class="text-xs text-slate-500 mt-1">Öka om mikrofonen är långt bort.</p>
                </div>

                <!-- Pan / Balance -->
                <div class="p-4 bg-slate-900 rounded-lg border border-slate-700">
                    <div class="flex justify-between mb-1">
                        <label class="text-sm font-medium text-green-300 flex items-center gap-1">
                            <i data-lucide="move-horizontal" class="w-4 h-4"></i> Balans
                        </label>
                        <span id="panVal" class="text-xs font-mono bg-slate-700 px-2 rounded">Mitten</span>
                    </div>
                    <div class="flex items-center gap-3 text-xs text-slate-400 font-bold">
                        <span>V (Bra öra)</span>
                        <input type="range" id="panSlider" min="-1" max="1" step="0.1" value="0" class="w-full">
                        <span>H</span>
                    </div>
                    <p class="text-xs text-slate-500 mt-2 text-center">Dra mot Vänster för att flytta ljudet till ditt friska öra.</p>
                </div>

                <!-- EQ Section -->
                <div class="space-y-4 pt-2 border-t border-slate-700">
                    <h3 class="text-sm font-bold text-slate-300 uppercase tracking-wider">Bullerreducering & Tal</h3>
                    
                    <!-- Low / Bass -->
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-slate-400">Lågbas (Buller)</span>
                            <span id="lowVal">0 dB</span>
                        </div>
                        <input type="range" id="lowSlider" min="-20" max="10" step="1" value="0" class="w-full">
                    </div>

                    <!-- Mid / Speech -->
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-yellow-400 font-bold">Röstfokus</span>
                            <span id="midVal">0 dB</span>
                        </div>
                        <input type="range" id="midSlider" min="-10" max="20" step="1" value="0" class="w-full">
                    </div>

                    <!-- High / Clarity -->
                    <div>
                        <div class="flex justify-between text-xs mb-1">
                            <span class="text-slate-400">Diskant (Skärpa)</span>
                            <span id="highVal">0 dB</span>
                        </div>
                        <input type="range" id="highSlider" min="-10" max="15" step="1" value="0" class="w-full">
                    </div>
                </div>
            </div>

        </div>
    </main>

    <script>
        // Init Lucide icons
        lucide.createIcons();

        // Audio Context & Nodes
        let audioCtx;
        let streamSource;
        let gainNode;
        let pannerNode;
        let compressorNode;
        let lowEQ, midEQ, highEQ;
        let analyser;
        let isRunning = false;
        let currentStream = null;
        let animationId;
        
        // Wake Lock Sentinel
        let wakeLock = null;

        // Elements
        const toggleBtn = document.getElementById('toggleBtn');
        const statusIndicator = document.getElementById('statusIndicator');
        const controlsArea = document.getElementById('controlsArea');
        const micSelect = document.getElementById('micSelect');
        const visualizerContainer = document.getElementById('visualizer-container');
        const wakeLockStatus = document.getElementById('wakeLockStatus');

        // Setup Visualizer Bars
        const barCount = 20;
        const bars = [];
        for (let i = 0; i < barCount; i++) {
            const bar = document.createElement('div');
            bar.className = 'bg-blue-500 w-full mx-0.5 rounded-t-sm opacity-80';
            bar.style.height = '5%';
            visualizerContainer.appendChild(bar);
            bars.push(bar);
        }

        // Initialize Audio Context on user interaction
        async function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
            }

            if (audioCtx.state === 'suspended') {
                await audioCtx.resume();
            }
        }

        // Wake Lock Functions
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    wakeLockStatus.classList.remove('hidden');
                    console.log('Screen Wake Lock aktivt');
                    
                    wakeLock.addEventListener('release', () => {
                        console.log('Screen Wake Lock släppt');
                        if (!isRunning) {
                             wakeLockStatus.classList.add('hidden');
                        }
                    });
                }
            } catch (err) {
                console.error(`Kunde inte aktivera Wake Lock: ${err.name}, ${err.message}`);
            }
        }

        async function releaseWakeLock() {
            if (wakeLock !== null) {
                await wakeLock.release();
                wakeLock = null;
                wakeLockStatus.classList.add('hidden');
            }
        }

        // Handle visibility change (re-acquire lock if tab becomes visible again)
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        async function getMicrophones() {
            try {
                // Request permission first to get labels if we don't have them
                // This is crucial on mobile to actually see the device names
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // We stop this temp stream immediately, we just needed the permission/labels
                stream.getTracks().forEach(track => track.stop());

                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioInputs = devices.filter(device => device.kind === 'audioinput');
                
                // Save current selection if possible
                const currentSelection = micSelect.value;
                micSelect.innerHTML = '';
                
                if (audioInputs.length === 0) {
                     micSelect.innerHTML = '<option disabled>Inga mikrofoner hittades</option>';
                     return;
                }

                audioInputs.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    // Fallback name if label is empty (common on mobile before permission)
                    option.text = device.label || `Mikrofon/Input (${device.deviceId.slice(0,5)}...)`;
                    micSelect.appendChild(option);
                });

                // Restore selection if it still exists
                if (currentSelection && [...micSelect.options].some(o => o.value === currentSelection)) {
                    micSelect.value = currentSelection;
                }

                // Add event listener for change
                micSelect.onchange = async (e) => {
                    if (isRunning) {
                        stopAudio();
                        await startAudio(e.target.value);
                    }
                };
                
                // Re-initialize icons for the new button
                lucide.createIcons();

            } catch (err) {
                console.error("Kunde inte hämta mikrofoner:", err);
                micSelect.innerHTML = '<option>Åtkomst nekad eller fel</option>';
            }
        }

        async function startAudio(deviceId = null) {
            try {
                await initAudio();
                
                // Activate Wake Lock
                await requestWakeLock();

                const constraints = {
                    audio: {
                        deviceId: deviceId ? { exact: deviceId } : undefined,
                        echoCancellation: false, // Turn off for cleaner raw audio usually
                        noiseSuppression: false, // We will handle EQ manually, but sometimes system NS is good.
                        autoGainControl: false,  // We want manual gain control
                        latency: 0
                    }
                };

                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Create Nodes
                streamSource = audioCtx.createMediaStreamSource(currentStream);
                gainNode = audioCtx.createGain();
                pannerNode = audioCtx.createStereoPanner();
                analyser = audioCtx.createAnalyser();
                compressorNode = audioCtx.createDynamicsCompressor(); // Limiter to protect ears
                
                // EQ Nodes (BiquadFilter)
                lowEQ = audioCtx.createBiquadFilter();
                lowEQ.type = 'lowshelf';
                lowEQ.frequency.value = 250; // Bass cutoff

                midEQ = audioCtx.createBiquadFilter();
                midEQ.type = 'peaking';
                midEQ.Q.value = 1;
                midEQ.frequency.value = 1500; // Human speech center

                highEQ = audioCtx.createBiquadFilter();
                highEQ.type = 'highshelf';
                highEQ.frequency.value = 5000; // Clarity/Treble

                // Apply initial UI values
                updateAudioParams();

                // Connect the chain: 
                // Source -> Compressor (Safety) -> LowEQ -> MidEQ -> HighEQ -> Gain -> Panner -> Analyser -> Destination
                streamSource
                    .connect(compressorNode)
                    .connect(lowEQ)
                    .connect(midEQ)
                    .connect(highEQ)
                    .connect(gainNode)
                    .connect(pannerNode)
                    .connect(analyser)
                    .connect(audioCtx.destination);

                // Setup Analyser for visualizer
                analyser.fftSize = 64;
                drawVisualizer();

                // UI Updates
                isRunning = true;
                updateUIState(true);

            } catch (err) {
                console.error("Fel vid start av ljud:", err);
                alert("Kunde inte starta mikrofonen. Försök att välja en annan mikrofon i listan.");
                stopAudio();
            }
        }

        function stopAudio() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            // Disconnect nodes if they exist
            if (streamSource) {
                streamSource.disconnect();
            }
            
            // Release Wake Lock
            releaseWakeLock();

            isRunning = false;
            updateUIState(false);
            
            // Reset visualizer
            bars.forEach(bar => bar.style.height = '5%');
        }

        function updateUIState(active) {
            if (active) {
                toggleBtn.innerHTML = '<i data-lucide="square" class="fill-current"></i> Stoppa Ljudet';
                toggleBtn.classList.remove('bg-green-600', 'hover:bg-green-500');
                toggleBtn.classList.add('bg-red-600', 'hover:bg-red-500');
                statusIndicator.innerText = "LIVE";
                statusIndicator.classList.remove('bg-red-900', 'text-red-200');
                statusIndicator.classList.add('bg-green-900', 'text-green-200');
                controlsArea.classList.remove('opacity-50', 'pointer-events-none');
                lucide.createIcons();
            } else {
                toggleBtn.innerHTML = '<i data-lucide="power"></i> Starta Ljudet';
                toggleBtn.classList.remove('bg-red-600', 'hover:bg-red-500');
                toggleBtn.classList.add('bg-green-600', 'hover:bg-green-500');
                statusIndicator.innerText = "OFFLINE";
                statusIndicator.classList.remove('bg-green-900', 'text-green-200');
                statusIndicator.classList.add('bg-red-900', 'text-red-200');
                controlsArea.classList.add('opacity-50', 'pointer-events-none');
                lucide.createIcons();
            }
        }

        function drawVisualizer() {
            if (!isRunning) return;
            
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteFrequencyData(dataArray);

            // Map data to bars
            // We only take a portion of the buffer because speech isn't usually in the super high freqs
            const step = Math.floor(bufferLength / barCount);

            for (let i = 0; i < barCount; i++) {
                const value = dataArray[i * step];
                const percent = (value / 255) * 100;
                
                bars[i].style.height = Math.max(5, percent) + '%';
                
                // Change color based on intensity
                if (percent > 80) {
                    bars[i].className = 'w-full mx-0.5 rounded-t-sm transition-all bg-red-500';
                } else if (percent > 50) {
                    bars[i].className = 'w-full mx-0.5 rounded-t-sm transition-all bg-yellow-500';
                } else {
                    bars[i].className = 'w-full mx-0.5 rounded-t-sm transition-all bg-blue-500';
                }
            }

            animationId = requestAnimationFrame(drawVisualizer);
        }

        function updateAudioParams() {
            if (!isRunning) return;

            // Gain
            const gainVal = parseFloat(document.getElementById('gainSlider').value);
            gainNode.gain.value = gainVal;
            document.getElementById('gainVal').innerText = gainVal.toFixed(1) + 'x';

            // Panner
            const panVal = parseFloat(document.getElementById('panSlider').value);
            pannerNode.pan.value = panVal;
            let panText = "Mitten";
            if (panVal < -0.1) panText = "Vänster";
            if (panVal > 0.1) panText = "Höger";
            document.getElementById('panVal').innerText = panText;

            // EQ
            const lowVal = parseFloat(document.getElementById('lowSlider').value);
            lowEQ.gain.value = lowVal;
            document.getElementById('lowVal').innerText = (lowVal > 0 ? '+' : '') + lowVal + ' dB';

            const midVal = parseFloat(document.getElementById('midSlider').value);
            midEQ.gain.value = midVal;
            document.getElementById('midVal').innerText = (midVal > 0 ? '+' : '') + midVal + ' dB';

            const highVal = parseFloat(document.getElementById('highSlider').value);
            highEQ.gain.value = highVal;
            document.getElementById('highVal').innerText = (highVal > 0 ? '+' : '') + highVal + ' dB';
        }

        // Event Listeners for Sliders
        ['gainSlider', 'panSlider', 'lowSlider', 'midSlider', 'highSlider'].forEach(id => {
            document.getElementById(id).addEventListener('input', updateAudioParams);
        });

        // Main Toggle Logic
        toggleBtn.addEventListener('click', () => {
            if (isRunning) {
                stopAudio();
            } else {
                startAudio(micSelect.value);
            }
        });

        // Load mics on load
        window.addEventListener('load', getMicrophones);
        
        // Listen for device changes (plugging in usb-c adapter)
        // Note: Not supported on all mobile browsers, hence the manual button
        if (navigator.mediaDevices) {
            navigator.mediaDevices.ondevicechange = () => {
                console.log("Enheter ändrades, uppdaterar lista...");
                getMicrophones();
            };
        }

    </script>
</body>
</html>
